\hypertarget{class_mesh_render_interface}{}\section{Mesh\+Render\+Interface Class Reference}
\label{class_mesh_render_interface}\index{Mesh\+Render\+Interface@{Mesh\+Render\+Interface}}


{\ttfamily \#include $<$interfaces.\+h$>$}



Inherits Mesh\+Common\+Interface.

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_mesh_render_interface_a6a66ca17371479cb2bf6fedc7a3789f3}\label{class_mesh_render_interface_a6a66ca17371479cb2bf6fedc7a3789f3}} 
virtual void {\bfseries Init} (Q\+Action $\ast$, Mesh\+Document \&, M\+L\+Scene\+G\+L\+Shared\+Data\+Context\+::\+Per\+Mesh\+Rendering\+Data\+Map \&, G\+L\+Area $\ast$)
\item 
\mbox{\Hypertarget{class_mesh_render_interface_a6e1b4e2e6b8f665e66521bf5cb0ac513}\label{class_mesh_render_interface_a6e1b4e2e6b8f665e66521bf5cb0ac513}} 
virtual void {\bfseries Render} (Q\+Action $\ast$, Mesh\+Document \&, M\+L\+Scene\+G\+L\+Shared\+Data\+Context\+::\+Per\+Mesh\+Rendering\+Data\+Map \&mp, G\+L\+Area $\ast$)=0
\item 
\mbox{\Hypertarget{class_mesh_render_interface_ada3e4ab4ce11bb0a14a9643b0f7927cf}\label{class_mesh_render_interface_ada3e4ab4ce11bb0a14a9643b0f7927cf}} 
virtual void {\bfseries Finalize} (Q\+Action $\ast$, Mesh\+Document $\ast$, G\+L\+Area $\ast$)
\item 
\mbox{\Hypertarget{class_mesh_render_interface_ab660f9bd5ab26b8278c137befc289e43}\label{class_mesh_render_interface_ab660f9bd5ab26b8278c137befc289e43}} 
virtual bool {\bfseries is\+Supported} ()=0
\item 
\mbox{\Hypertarget{class_mesh_render_interface_abed900d01387bfb0f3c0c0b0224ee1d4}\label{class_mesh_render_interface_abed900d01387bfb0f3c0c0b0224ee1d4}} 
virtual Q\+List$<$ Q\+Action $\ast$ $>$ {\bfseries actions} ()=0
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Used to customized the rendering process. Rendering plugins are now responsible of the rendering of the whole Mesh\+Document and not only of a single Mesh\+Model.

The Render function is called in with the Model\+View and Projection Matrices already set up, screen cleared and background drawn. After the Render call the Mesh\+Lab frawework draw on the opengl context other decorations and the trackball, so it there is the requirement for a rendering plugin is that it should leave the z-\/buffer in a coherent state.

The typical rendering loop of a Render plugin is something like, \+:

$<$your own=\char`\"{}\char`\"{} opengl=\char`\"{}\char`\"{} setup$>$=\char`\"{}\char`\"{}$>$ \begin{DoxyVerb}            foreach(MeshModel * mp, meshDoc.meshList)
                            {
                                    if(mp->visible) mp->Render(rm.drawMode,rm.colorMode,rm.textureMode);
                            }\end{DoxyVerb}
 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/\+Users/waleedzafar/\+Projects/\+F\+Y\+P/one/libs/meshlab/src/common/interfaces.\+h\end{DoxyCompactItemize}
